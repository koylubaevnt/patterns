
# Фабричный метод
Также известен как: Виртуальный конструктор, Factory Method

## Источник
[Refactoring GURU: Фабричный метод](https://refactoring.guru/ru/design-patterns/factory-method)


## Суть паттерна

**Фабричный метод** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![](essence-pattern.png)

## Проблема

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса *Грузовик*.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

![](logistics-app.png)

Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам Грузовиков. Чтобы добавить в программу классы морских Судов, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

## Решение

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор *new*, а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи *new*, но делать это будет фабричный метод.

![](solution-hierarhy-0.png)

На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

![](solution-hierarhy-1.png)

Например, классы *Грузовик* и *Судно* реализуют интерфейс *Транспорт* с методом доставить. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе *ДорожнойЛогистики* вернёт объект-грузовик, а класс *МорскойЛогистики* — объект-судно.

![](solution-hierarhy-2.png)

Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный *Транспорт*. Для него будет важно, чтобы объект имел метод *доставить*, а как конкретно он работает — не важно.

## Структура

1. **Продукт** определяет общий интерфейс объектов, которые может произвести создатель и его подклассы.
2. **Конкретные продукты** содержат код различных продуктов. Продукты будут отличаться реализацией, но интерфейс у них будет общий.
3. **Создатель** объявляет фабричный метод, который должен возвращать новые объекты продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом продуктов.<br/>Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы реализовать его по-своему. Но он может возвращать и некий стандартный продукт.<br/>Несмотря на название, важно понимать, что создание продуктов не является единственной функцией создателя. Обычно он содержит и другой полезный код работы с продуктом. Аналогия: большая софтверная компания может иметь центр подготовки программистов, но основная задача компании — создавать программные продукты, а не готовить программистов.
4. **Конкретные создатели** по-своему реализуют фабричный метод, производя те или иные конкретные продукты.<br/>Фабричный метод не обязан всё время создавать новые объекты. Его можно переписать так, чтобы возвращать существующие объекты из какого-то хранилища или кэша.

![](structure.png)

## Применимость

* Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.

    > Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует. <p>Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

* Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.

    > Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных? <p>Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.<p>Например, вы используете готовый UI-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс *RoundButton*. Но как сказать главному классу фреймворка *UIFramework*, чтобы он теперь создавал круглые кнопки, вместо стандартных?<p>Для этого вы создаёте подкласс *UIWithRoundButtons* из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля *createButton*) и вписываете туда создание своего класса кнопок. Затем используете *UIWithRoundButtons* вместо стандартного *UIFramework*.

* Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.

    > Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, файловой системе и т. д.<p>Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:</p>
    > * Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
    > * При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
    > * А затем вернуть его клиентскому коду.
    > * Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище.
    > <p>Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.</p><p>Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.<p>Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.</p>

## Шаги реализации

1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов. <p>
В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.<p>
На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.<p>
    > Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта, а также классы продуктов Самолёт, Грузовик и Поезд. Авиа соответствует Самолётам, но для НаземнойПочты есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод НаземнойПочты аргумент, контролирующий тип создаваемого продукта.
6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.

## Преимущества и недостатки

<table>
  <thead>
    <tr>
      <th>Преимущества</th>
      <th>Недостатки</th>
    </tr>
  </thead>
  <tbody >
    <tr>
      <td>Избавляет класс от привязки к конкретным классам продуктов.</td>
      <td rowspan="4">Может привести к созданию больших <b>параллельных иерархий классов</b>, так как для каждого класса продукта надо создать свой подкласс создателя.</td>
    </tr>
    <tr>
      <td>Выделяет код производства продуктов в одно место, упрощая поддержку кода.</td>
    </tr>
    <tr>
      <td>Упрощает добавление новых продуктов в программу.</td>
    </tr>
    <tr>
      <td>Реализует <i>принцип открытости/закрытости</i>.</td>
    </tr>
  </tbody>
</table>

## Запуск примера

### Сборка

    * mvn clean package

### HTML Button

    * java -Dfile.encoding=UTF-8 -classpath target/classes ru.koylubaevnt.patterns.creational.factorymethod.Demo

### Windows Button

    * java -Dfile.encoding=UTF-8 -classpath target/classes ru.koylubaevnt.patterns.creational.factorymethod.Demo 1
